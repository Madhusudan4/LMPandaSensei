{"ast":null,"code":"// Function to split text into reasonably-sized chunks\nexport function splitTextIntoChunks(text, maxChunkSize = 1000, overlap = 200) {\n  // Clean up the text - remove excessive whitespace\n  const cleanedText = text.replace(/\\s+/g, ' ').trim();\n\n  // If text is short enough, return it as a single chunk\n  if (cleanedText.length <= maxChunkSize) {\n    return [cleanedText];\n  }\n  const chunks = [];\n  let startIndex = 0;\n  while (startIndex < cleanedText.length) {\n    let endIndex = startIndex + maxChunkSize;\n\n    // If we're not at the end of the text, try to break at a sentence boundary\n    if (endIndex < cleanedText.length) {\n      // Look backward from maxChunkSize for a sentence boundary\n      const sentenceEndMatch = cleanedText.substring(startIndex, endIndex + 1).match(/[.!?]\\s+[A-Z][^.!?]*$/);\n      if (sentenceEndMatch) {\n        // Adjust the endIndex to the end of the last complete sentence\n        endIndex = startIndex + sentenceEndMatch.index + 1;\n      } else {\n        // If no sentence boundary found, look for a space\n        const lastSpace = cleanedText.substring(startIndex, endIndex + 1).lastIndexOf(' ');\n        if (lastSpace > 0) {\n          endIndex = startIndex + lastSpace;\n        }\n      }\n    } else {\n      // If we're at the end of the text, just use the remaining text\n      endIndex = cleanedText.length;\n    }\n\n    // Extract the chunk and add it to the array\n    chunks.push(cleanedText.substring(startIndex, endIndex).trim());\n\n    // Move the start index for the next chunk, including overlap\n    startIndex = Math.min(endIndex, startIndex + maxChunkSize - overlap);\n  }\n  return chunks;\n}","map":{"version":3,"names":["splitTextIntoChunks","text","maxChunkSize","overlap","cleanedText","replace","trim","length","chunks","startIndex","endIndex","sentenceEndMatch","substring","match","index","lastSpace","lastIndexOf","push","Math","min"],"sources":["/Users/madhu.sudhan/Documents/logistics-chatbot/src/utils/textProcessing.js"],"sourcesContent":["// Function to split text into reasonably-sized chunks\nexport function splitTextIntoChunks(text, maxChunkSize = 1000, overlap = 200) {\n    // Clean up the text - remove excessive whitespace\n    const cleanedText = text.replace(/\\s+/g, ' ').trim();\n    \n    // If text is short enough, return it as a single chunk\n    if (cleanedText.length <= maxChunkSize) {\n      return [cleanedText];\n    }\n    \n    const chunks = [];\n    let startIndex = 0;\n    \n    while (startIndex < cleanedText.length) {\n      let endIndex = startIndex + maxChunkSize;\n      \n      // If we're not at the end of the text, try to break at a sentence boundary\n      if (endIndex < cleanedText.length) {\n        // Look backward from maxChunkSize for a sentence boundary\n        const sentenceEndMatch = cleanedText.substring(startIndex, endIndex + 1)\n          .match(/[.!?]\\s+[A-Z][^.!?]*$/);\n        \n        if (sentenceEndMatch) {\n          // Adjust the endIndex to the end of the last complete sentence\n          endIndex = startIndex + sentenceEndMatch.index + 1;\n        } else {\n          // If no sentence boundary found, look for a space\n          const lastSpace = cleanedText.substring(startIndex, endIndex + 1).lastIndexOf(' ');\n          if (lastSpace > 0) {\n            endIndex = startIndex + lastSpace;\n          }\n        }\n      } else {\n        // If we're at the end of the text, just use the remaining text\n        endIndex = cleanedText.length;\n      }\n      \n      // Extract the chunk and add it to the array\n      chunks.push(cleanedText.substring(startIndex, endIndex).trim());\n      \n      // Move the start index for the next chunk, including overlap\n      startIndex = Math.min(endIndex, startIndex + maxChunkSize - overlap);\n    }\n    \n    return chunks;\n  }\n  "],"mappings":"AAAA;AACA,OAAO,SAASA,mBAAmBA,CAACC,IAAI,EAAEC,YAAY,GAAG,IAAI,EAAEC,OAAO,GAAG,GAAG,EAAE;EAC1E;EACA,MAAMC,WAAW,GAAGH,IAAI,CAACI,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,CAAC;;EAEpD;EACA,IAAIF,WAAW,CAACG,MAAM,IAAIL,YAAY,EAAE;IACtC,OAAO,CAACE,WAAW,CAAC;EACtB;EAEA,MAAMI,MAAM,GAAG,EAAE;EACjB,IAAIC,UAAU,GAAG,CAAC;EAElB,OAAOA,UAAU,GAAGL,WAAW,CAACG,MAAM,EAAE;IACtC,IAAIG,QAAQ,GAAGD,UAAU,GAAGP,YAAY;;IAExC;IACA,IAAIQ,QAAQ,GAAGN,WAAW,CAACG,MAAM,EAAE;MACjC;MACA,MAAMI,gBAAgB,GAAGP,WAAW,CAACQ,SAAS,CAACH,UAAU,EAAEC,QAAQ,GAAG,CAAC,CAAC,CACrEG,KAAK,CAAC,uBAAuB,CAAC;MAEjC,IAAIF,gBAAgB,EAAE;QACpB;QACAD,QAAQ,GAAGD,UAAU,GAAGE,gBAAgB,CAACG,KAAK,GAAG,CAAC;MACpD,CAAC,MAAM;QACL;QACA,MAAMC,SAAS,GAAGX,WAAW,CAACQ,SAAS,CAACH,UAAU,EAAEC,QAAQ,GAAG,CAAC,CAAC,CAACM,WAAW,CAAC,GAAG,CAAC;QAClF,IAAID,SAAS,GAAG,CAAC,EAAE;UACjBL,QAAQ,GAAGD,UAAU,GAAGM,SAAS;QACnC;MACF;IACF,CAAC,MAAM;MACL;MACAL,QAAQ,GAAGN,WAAW,CAACG,MAAM;IAC/B;;IAEA;IACAC,MAAM,CAACS,IAAI,CAACb,WAAW,CAACQ,SAAS,CAACH,UAAU,EAAEC,QAAQ,CAAC,CAACJ,IAAI,CAAC,CAAC,CAAC;;IAE/D;IACAG,UAAU,GAAGS,IAAI,CAACC,GAAG,CAACT,QAAQ,EAAED,UAAU,GAAGP,YAAY,GAAGC,OAAO,CAAC;EACtE;EAEA,OAAOK,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}